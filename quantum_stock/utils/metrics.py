# -*- coding: utf-8 -*-
"""
Prometheus Metrics for VN-QUANT
================================
Production-grade metrics collection and exposition.

Metrics Categories:
- Trading metrics (orders, fills, P&L)
- System metrics (CPU, memory, requests)
- Agent metrics (accuracy, performance)
- Data metrics (latency, quality)
"""

from typing import Dict, Optional, List
from dataclasses import dataclass
from datetime import datetime
import time

try:
    from prometheus_client import (
        Counter, Gauge, Histogram, Summary,
        CollectorRegistry, generate_latest,
        CONTENT_TYPE_LATEST, start_http_server
    )
    PROMETHEUS_AVAILABLE = True
except ImportError:
    PROMETHEUS_AVAILABLE = False
    print("⚠️ prometheus_client not installed. Run: pip install prometheus-client")


class PrometheusMetrics:
    """
    Centralized Prometheus metrics for VN-QUANT

    Usage:
        metrics = PrometheusMetrics()
        metrics.record_order("BUY", "VCB", "FILLED")
        metrics.record_pnl(1500000)  # 1.5M VND profit
    """

    def __init__(self, registry: Optional[CollectorRegistry] = None):
        if not PROMETHEUS_AVAILABLE:
            self.enabled = False
            return

        self.enabled = True
        self.registry = registry or CollectorRegistry()

        # ====================================
        # TRADING METRICS
        # ====================================

        # Order counters
        self.orders_total = Counter(
            "vnquant_orders_total",
            "Total number of orders placed",
            ["order_type", "symbol", "status"],
            registry=self.registry
        )

        self.orders_filled = Counter(
            "vnquant_orders_filled_total",
            "Total number of filled orders",
            ["order_type", "symbol"],
            registry=self.registry
        )

        self.orders_rejected = Counter(
            "vnquant_orders_rejected_total",
            "Total number of rejected orders",
            ["order_type", "symbol", "reason"],
            registry=self.registry
        )

        # P&L metrics
        self.pnl_realized = Gauge(
            "vnquant_pnl_realized_vnd",
            "Realized profit/loss in VND",
            registry=self.registry
        )

        self.pnl_unrealized = Gauge(
            "vnquant_pnl_unrealized_vnd",
            "Unrealized profit/loss in VND",
            registry=self.registry
        )

        self.portfolio_value = Gauge(
            "vnquant_portfolio_value_vnd",
            "Total portfolio value in VND",
            registry=self.registry
        )

        self.cash_available = Gauge(
            "vnquant_cash_available_vnd",
            "Available cash in VND",
            registry=self.registry
        )

        # Position metrics
        self.positions_open = Gauge(
            "vnquant_positions_open",
            "Number of open positions",
            registry=self.registry
        )

        self.position_value = Gauge(
            "vnquant_position_value_vnd",
            "Position value in VND",
            ["symbol"],
            registry=self.registry
        )

        # Trade metrics
        self.trade_duration_seconds = Histogram(
            "vnquant_trade_duration_seconds",
            "Time from order to fill in seconds",
            ["order_type"],
            buckets=[0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 30.0, 60.0],
            registry=self.registry
        )

        self.trade_slippage = Histogram(
            "vnquant_trade_slippage_pct",
            "Slippage percentage",
            ["order_type"],
            buckets=[0.001, 0.005, 0.01, 0.02, 0.05, 0.1],
            registry=self.registry
        )

        # ====================================
        # AGENT METRICS
        # ====================================

        self.agent_signals = Counter(
            "vnquant_agent_signals_total",
            "Total signals generated by agents",
            ["agent_name", "signal_type"],
            registry=self.registry
        )

        self.agent_accuracy = Gauge(
            "vnquant_agent_accuracy",
            "Agent prediction accuracy",
            ["agent_name"],
            registry=self.registry
        )

        self.agent_sharpe_ratio = Gauge(
            "vnquant_agent_sharpe_ratio",
            "Agent Sharpe ratio",
            ["agent_name"],
            registry=self.registry
        )

        self.consensus_strength = Histogram(
            "vnquant_consensus_strength",
            "Strength of agent consensus",
            buckets=[0.0, 0.2, 0.4, 0.6, 0.8, 1.0],
            registry=self.registry
        )

        # ====================================
        # SYSTEM METRICS
        # ====================================

        self.http_requests = Counter(
            "vnquant_http_requests_total",
            "Total HTTP requests",
            ["method", "endpoint", "status"],
            registry=self.registry
        )

        self.http_request_duration = Histogram(
            "vnquant_http_request_duration_seconds",
            "HTTP request duration",
            ["method", "endpoint"],
            buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.0, 5.0],
            registry=self.registry
        )

        self.errors_total = Counter(
            "vnquant_errors_total",
            "Total errors",
            ["error_type", "component"],
            registry=self.registry
        )

        # ====================================
        # DATA METRICS
        # ====================================

        self.data_fetches = Counter(
            "vnquant_data_fetches_total",
            "Total data fetches",
            ["source", "symbol", "status"],
            registry=self.registry
        )

        self.data_latency = Histogram(
            "vnquant_data_latency_seconds",
            "Data fetch latency",
            ["source"],
            buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.0, 5.0, 10.0],
            registry=self.registry
        )

        self.data_cache_hits = Counter(
            "vnquant_data_cache_hits_total",
            "Cache hits",
            ["cache_type"],
            registry=self.registry
        )

        self.data_cache_misses = Counter(
            "vnquant_data_cache_misses_total",
            "Cache misses",
            ["cache_type"],
            registry=self.registry
        )

        # ====================================
        # RISK METRICS
        # ====================================

        self.circuit_breaker_level = Gauge(
            "vnquant_circuit_breaker_level",
            "Circuit breaker level (0-3)",
            registry=self.registry
        )

        self.risk_score = Gauge(
            "vnquant_risk_score",
            "Current risk score",
            ["symbol"],
            registry=self.registry
        )

        self.max_drawdown = Gauge(
            "vnquant_max_drawdown_pct",
            "Maximum drawdown percentage",
            registry=self.registry
        )

        self.daily_loss_pct = Gauge(
            "vnquant_daily_loss_pct",
            "Daily loss percentage",
            registry=self.registry
        )

    # ====================================
    # TRADING METHODS
    # ====================================

    def record_order(self, order_type: str, symbol: str, status: str):
        """Record order placement"""
        if not self.enabled:
            return
        self.orders_total.labels(
            order_type=order_type,
            symbol=symbol,
            status=status
        ).inc()

    def record_fill(self, order_type: str, symbol: str, duration_seconds: float, slippage_pct: float):
        """Record order fill"""
        if not self.enabled:
            return
        self.orders_filled.labels(order_type=order_type, symbol=symbol).inc()
        self.trade_duration_seconds.labels(order_type=order_type).observe(duration_seconds)
        self.trade_slippage.labels(order_type=order_type).observe(slippage_pct)

    def record_rejection(self, order_type: str, symbol: str, reason: str):
        """Record order rejection"""
        if not self.enabled:
            return
        self.orders_rejected.labels(
            order_type=order_type,
            symbol=symbol,
            reason=reason
        ).inc()

    def update_portfolio(self, total_value: float, cash: float, realized_pnl: float, unrealized_pnl: float):
        """Update portfolio metrics"""
        if not self.enabled:
            return
        self.portfolio_value.set(total_value)
        self.cash_available.set(cash)
        self.pnl_realized.set(realized_pnl)
        self.pnl_unrealized.set(unrealized_pnl)

    def update_positions(self, num_positions: int, positions: Dict[str, float]):
        """Update position metrics"""
        if not self.enabled:
            return
        self.positions_open.set(num_positions)
        for symbol, value in positions.items():
            self.position_value.labels(symbol=symbol).set(value)

    # ====================================
    # AGENT METHODS
    # ====================================

    def record_agent_signal(self, agent_name: str, signal_type: str):
        """Record agent signal"""
        if not self.enabled:
            return
        self.agent_signals.labels(
            agent_name=agent_name,
            signal_type=signal_type
        ).inc()

    def update_agent_performance(self, agent_name: str, accuracy: float, sharpe_ratio: float):
        """Update agent performance metrics"""
        if not self.enabled:
            return
        self.agent_accuracy.labels(agent_name=agent_name).set(accuracy)
        self.agent_sharpe_ratio.labels(agent_name=agent_name).set(sharpe_ratio)

    def record_consensus(self, strength: float):
        """Record consensus strength"""
        if not self.enabled:
            return
        self.consensus_strength.observe(strength)

    # ====================================
    # SYSTEM METHODS
    # ====================================

    def record_http_request(self, method: str, endpoint: str, status: int, duration: float):
        """Record HTTP request"""
        if not self.enabled:
            return
        self.http_requests.labels(
            method=method,
            endpoint=endpoint,
            status=str(status)
        ).inc()
        self.http_request_duration.labels(
            method=method,
            endpoint=endpoint
        ).observe(duration)

    def record_error(self, error_type: str, component: str):
        """Record error"""
        if not self.enabled:
            return
        self.errors_total.labels(
            error_type=error_type,
            component=component
        ).inc()

    # ====================================
    # DATA METHODS
    # ====================================

    def record_data_fetch(self, source: str, symbol: str, status: str, latency: float):
        """Record data fetch"""
        if not self.enabled:
            return
        self.data_fetches.labels(
            source=source,
            symbol=symbol,
            status=status
        ).inc()
        self.data_latency.labels(source=source).observe(latency)

    def record_cache_hit(self, cache_type: str):
        """Record cache hit"""
        if not self.enabled:
            return
        self.data_cache_hits.labels(cache_type=cache_type).inc()

    def record_cache_miss(self, cache_type: str):
        """Record cache miss"""
        if not self.enabled:
            return
        self.data_cache_misses.labels(cache_type=cache_type).inc()

    # ====================================
    # RISK METHODS
    # ====================================

    def update_circuit_breaker(self, level: int):
        """Update circuit breaker level"""
        if not self.enabled:
            return
        self.circuit_breaker_level.set(level)

    def update_risk_score(self, symbol: str, score: float):
        """Update risk score"""
        if not self.enabled:
            return
        self.risk_score.labels(symbol=symbol).set(score)

    def update_drawdown(self, drawdown_pct: float):
        """Update max drawdown"""
        if not self.enabled:
            return
        self.max_drawdown.set(drawdown_pct)

    def update_daily_loss(self, loss_pct: float):
        """Update daily loss"""
        if not self.enabled:
            return
        self.daily_loss_pct.set(loss_pct)

    # ====================================
    # EXPORT
    # ====================================

    def get_metrics(self) -> bytes:
        """
        Get metrics in Prometheus format

        Returns:
            Metrics as bytes
        """
        if not self.enabled:
            return b""
        return generate_latest(self.registry)

    def start_server(self, port: int = 9090):
        """
        Start Prometheus metrics HTTP server

        Args:
            port: Port to listen on
        """
        if not self.enabled:
            print("⚠️ Prometheus not available, server not started")
            return

        start_http_server(port, registry=self.registry)
        print(f"✅ Prometheus metrics server started on port {port}")


# Context manager for timing operations
class MetricsTimer:
    """
    Context manager for timing operations and recording to metrics

    Usage:
        with MetricsTimer(metrics, "data_fetch", source="ssi"):
            fetch_data()
    """

    def __init__(self, metrics: PrometheusMetrics, operation: str, **labels):
        self.metrics = metrics
        self.operation = operation
        self.labels = labels
        self.start_time = None

    def __enter__(self):
        self.start_time = time.time()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        duration = time.time() - self.start_time

        # Record based on operation type
        if self.operation == "http_request":
            status = 500 if exc_type else 200
            self.metrics.record_http_request(
                self.labels.get("method", "GET"),
                self.labels.get("endpoint", "/"),
                status,
                duration
            )
        elif self.operation == "data_fetch":
            status = "error" if exc_type else "success"
            self.metrics.record_data_fetch(
                self.labels.get("source", "unknown"),
                self.labels.get("symbol", ""),
                status,
                duration
            )


# Global metrics instance
_metrics: Optional[PrometheusMetrics] = None


def setup_metrics(port: Optional[int] = None) -> PrometheusMetrics:
    """
    Setup global metrics and optionally start server

    Args:
        port: Port for Prometheus server (None = don't start)

    Returns:
        PrometheusMetrics instance
    """
    global _metrics
    _metrics = PrometheusMetrics()

    if port:
        _metrics.start_server(port)

    return _metrics


def get_metrics() -> PrometheusMetrics:
    """Get global metrics instance"""
    if _metrics is None:
        setup_metrics()
    return _metrics


__all__ = [
    "PrometheusMetrics",
    "MetricsTimer",
    "setup_metrics",
    "get_metrics",
    "PROMETHEUS_AVAILABLE"
]
